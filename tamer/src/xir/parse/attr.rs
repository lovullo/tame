// XIR attribute parser generator
//
//  Copyright (C) 2014-2022 Ryan Specialty Group, LLC.
//
//  This file is part of TAME.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

//! Attribute parser generator for parsing of [XIRF](super::super::flat).
//!
//! The parser generator is invoked via the macro
//!   [`attr_parse!`](crate::attr_parse),
//!   which expects a struct-like definition describing the mapping between
//!   attribute names and the final value.
//! It produces both an [`AttrParseState`] parser and a concrete struct to
//!   be yielded by the parser.
//! The parser completes upon reaching a dead state.
//!
//! Required attributes are checked after reaching a dead state,
//!   so attributes may appear in any order.
//! Further,
//!   the struct produced by the parser will contain an [`Option`] type
//!   _only_ for the optional fields,
//!     freeing the caller from having to deal with wrapped values.
//!
//! The parser automatically produces detailed error and diagnostic
//!   messages.

use super::AttrParseError;
use crate::{
    diagnose::Diagnostic,
    parse::{ClosedParseState, ParseState},
    xir::{OpenSpan, QName},
};
use std::{convert::Infallible, fmt::Debug};

/// Attribute parsing automaton.
///
/// These parsers are generated by [`attr_parse!`](crate::attr_parse).
pub trait AttrParseState: ClosedParseState {
    /// Type of error for failed parsing of attribute values.
    ///
    /// These originate from [`TryFrom`] conversions on the attribute
    ///   value.
    /// The default is [`Infallible`],
    ///   meaning such conversion cannot fail and [`From`] may be used in
    ///   place of [`TryFrom`].
    type ValueError: Diagnostic + PartialEq = Infallible;

    /// Object holding the current state of field aggregation,
    ///   before the yield of the final object.
    type Fields: Debug + PartialEq + Eq;

    /// Begin attribute parsing within the context of the provided element.
    ///
    /// This is used to provide diagnostic information.
    fn with_element(ele: QName, span: OpenSpan) -> Self;

    /// Name of the element being parsed.
    fn element_name(&self) -> QName;

    /// Span associated with the element being parsed.
    fn element_span(&self) -> OpenSpan;

    /// Attempt to narrow into the final type by checking the availability
    ///   of required attribute values.
    ///
    /// If a single missing required attribute does not have a value,
    ///   this will fail with [`AttrParseError::MissingRequired`],
    ///     which contains the parsing state that wraps every field type in
    ///     [`Option`].
    /// The caller may use this to recover as much data as it can,
    ///   or choose to allow it to fail with an error stating which fields
    ///   are missing.
    /// The list of missing fields is generated dynamically during
    ///   diagnostic reporting.
    fn finalize_attr(
        self,
        ctx: &mut <Self as ParseState>::Context,
    ) -> Result<Self::Object, AttrParseError<Self>>;

    /// Names of attributes that are required but do not yet have a value.
    fn required_missing(&self, ctx: &Self::Fields) -> Vec<QName>;
}

/// Parse attributes for the given element.
///
/// This function is useful when the type of [`AttrParseState`]Â `S` can be
///   inferred,
///     so that the expression reads more like natural language.
pub fn parse_attrs<S: AttrParseState>(ele: QName, span: OpenSpan) -> S {
    S::with_element(ele, span)
}

#[macro_export]
macro_rules! attr_parse {
    ($(#[$sattr:meta])*
        $(vis($vis:vis);)?
        $(type ValueError = $evty:ty;)?

        struct $(#[$st_attr:meta])? $state_name:ident -> $struct_name:ident {
            $(
                $(#[$fattr:meta])*
                $field:ident: ($qname:ident $($fmod:tt)?) => $ty:ty,
            )*
        }
    ) => { paste::paste! {
        $(
            // This provides a nice error on $ty itself at the call site,
            //   rather than relying on `Into::into` to cause the error
            //   later on,
            //     which places the error inside the macro definition.
            $crate::attr_parse!(@ty_assert $($fmod)? $ty);
        )*

        $(#[$st_attr])?
        ///
        #[doc=concat!("Parser producing [`", stringify!($struct_name), "`].")]
        ///
        /// Unlike the final type,
        ///   this is an intermediate representation that holds every
        ///   pending value within an [`Option`] as it awaits further input,
        ///     before finally being narrowed into
        #[doc=concat!("[`", stringify!($struct_name), "`].")]
        ///
        /// This object is exposed for recovery and error reporting on
        ///   [`AttrParseError::MissingRequired`][MissingRequired].
        ///
        /// [MissingRequired]: crate::xir::parse::AttrParseError::MissingRequired
        // TODO: This can be extracted out of the macro.
        #[derive(Debug, PartialEq, Eq)]
        $($vis)? enum $state_name {
            Parsing(crate::xir::QName, crate::xir::OpenSpan),
            Done(crate::xir::QName, crate::xir::OpenSpan),
        }

        #[doc(hidden)]
        #[allow(non_camel_case_types)]
        $($vis)? type [<$state_name Context>] =
            crate::parse::Context<[<$state_name Fields>]>;

        /// Intermediate state of parser as fields are aggregated.
        #[allow(non_camel_case_types)]
        #[derive(Debug, PartialEq, Eq, Default)]
        $($vis)? struct [<$state_name Fields>] {
            $(
                // Value + key span
                pub $field: Option<($ty, crate::span::Span)>,
            )*
        }

        impl crate::xir::parse::AttrParseState for $state_name {
            type ValueError = $crate::attr_parse!(@evty $($evty)?);
            type Fields = [<$state_name Fields>];

            fn with_element(
                ele: crate::xir::QName,
                span: crate::xir::OpenSpan
            ) -> Self {
                Self::Parsing(ele, span)
            }

            fn element_name(&self) -> crate::xir::QName {
                match self {
                    Self::Parsing(qname, _) | Self::Done(qname, _) => *qname,
                }
            }

            fn element_span(&self) -> crate::xir::OpenSpan {
                match self {
                    Self::Parsing(_, span) | Self::Done(_, span) => *span,
                }
            }

            fn finalize_attr(
                self,
                ctx: &mut <Self as crate::parse::ParseState>::Context,
            ) -> Result<
                Self::Object,
                crate::xir::parse::AttrParseError<Self>,
            > {
                // Will be unused if there are no fields.
                #[allow(unused_variables)]
                let fields: Self::Fields = std::mem::take(ctx);

                // Validate required fields before we start moving data.
                $(
                    $crate::attr_parse!(@if_missing_req $($fmod)? fields.$field {
                        return Err(
                            crate::xir::parse::AttrParseError::MissingRequired(
                                self,
                                fields,
                            )
                        )
                    });
                )*

                let obj = $struct_name {
                    $(
                        $field: $crate::attr_parse!(
                            @maybe_value $($fmod)? fields.$field
                        ),
                    )*
                };

                Ok(obj)
            }

            fn required_missing(
                &self,
                #[allow(unused_variables)] // unused if no fields
                ctx: &Self::Fields
            ) -> Vec<crate::xir::QName> {
                #[allow(unused_mut)]
                let mut missing = vec![];

                $(
                    $crate::attr_parse!(@if_missing_req $($fmod)? ctx.$field {
                        missing.push($qname);
                    });
                )*

                missing
            }
        }

        impl $state_name {
            fn done_with_element(
                ele: crate::xir::QName,
                span: crate::xir::OpenSpan,
            ) -> Self {
                Self::Done(ele, span)
            }
        }

        $(#[$sattr])*
        #[derive(Debug, PartialEq)]
        $($vis)? struct $struct_name {
            $(
                $(#[$fattr])*
                pub $field: $ty,
            )*
        }

        impl crate::parse::Object for $struct_name {}

        impl std::fmt::Display for $state_name {
            /// Additional error context shown in diagnostic messages for
            ///   certain variants of [`ParseError`].
            ///
            /// [`ParseError`]: crate::parse::ParseError
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                use crate::fmt::{DisplayWrapper, TtQuote};
                use crate::xir::parse::AttrParseState;

                write!(
                    f,
                    "expecting attributes for element {}",
                    TtQuote::wrap(self.element_name())
                )
            }
        }

        impl crate::parse::ParseState for $state_name {
            type Token = crate::xir::flat::XirfToken<
                crate::xir::flat::RefinedText
            >;
            type Object = $struct_name;
            type Error = crate::xir::parse::AttrParseError<Self>;
            type Context = [<$state_name Context>];

            fn parse_token(
                #[allow(unused_mut)]
                mut self,
                tok: Self::Token,
                ctx: &mut Self::Context,
            ) -> crate::parse::TransitionResult<Self> {
                use crate::parse::{Transition, Transitionable, ParseStatus};
                use crate::xir::{
                    flat,
                    parse::{AttrParseError, AttrParseState}
                };
                #[allow(unused_imports)]
                use crate::xir::attr::{Attr, AttrSpan}; // unused if no attrs

                let ele_name = self.element_name();

                match (self, tok) {
                    $(
                        // Use guard so we don't bind as a variable if we
                        //   forget to import a const for `$qname`.
                        // We don't use `$qname:pat` because we reuse
                        //   `$qname` for error messages.
                        (st @ Self::Parsing(_, _), flat::XirfToken::Attr(
                            attr @ Attr(qn, _, AttrSpan(kspan, _))
                        )) if qn == $qname => {
                            match ctx.$field {
                                // Duplicate attribute name
                                Some((_, first_kspan)) => {
                                    Transition(st).err(
                                        AttrParseError::DuplicateAttr(
                                            attr,
                                            first_kspan,
                                            ele_name,
                                        )
                                    )
                                }

                                // First time seeing attribute name
                                None => {
                                    let result = $crate::attr_parse!(
                                        @into_value $($fmod)? attr
                                    );

                                    match result {
                                        Ok(value) => {
                                            ctx.$field.replace((
                                                value,
                                                kspan,
                                            ));

                                            Transition(st).incomplete()
                                        },

                                        Err(e) => Transition(st).err(
                                            // Will complain about
                                            //   `Into::into` if Infallible.
                                            #[allow(unreachable_code)]
                                            AttrParseError::InvalidValue(
                                                e.into(),
                                                ele_name,
                                            )
                                        ),
                                    }
                                }
                            }
                        }
                    )*

                    (st @ Self::Parsing(_, _), flat::XirfToken::Attr(attr)) => {
                        Transition(st).err(AttrParseError::UnexpectedAttr(
                            attr,
                            ele_name,
                        ))
                    },

                    // Aggregation complete (dead state).
                    (Self::Parsing(ele, span), tok_dead) => {
                        Self::Parsing(ele, span).finalize_attr(ctx)
                            .map(ParseStatus::Object)
                            .transition(Self::done_with_element(ele, span))
                            .with_lookahead(tok_dead)
                    }

                    // Any tokens received after aggregation is completed
                    //   must not be processed,
                    //     otherwise we'll recurse indefinitely.
                    (st @ Self::Done(_, _), tok_dead) => {
                        Transition(st).dead(tok_dead)
                    }
                }
            }

            fn is_accepting(&self, _: &Self::Context) -> bool {
                // We must always be consumed via the dead state.
                false
            }
        }
    } };

    // Optional attribute if input above is of the form `(QN_FOO?) => ...`.
    (@ty_assert ? $ty:ty) => {
        // This type assertion isn't supported by `assert_impl_all!`.
        // The error isn't the most clear,
        //   but it's better than nothing and we can improve upon it later
        //   on.
        const _: fn() = || {
            trait OptionFromAttr {}
            impl<T: TryFrom<Attr>> OptionFromAttr for Option<T> {}

            // Fail when `$ty` is not Option<impl TryFrom<Attr>>.
            fn assert_attr_option<T: OptionFromAttr>() {}
            assert_attr_option::<$ty>();
        };
    };

    (@ty_assert $ty:ty) => {
        assert_impl_all!($ty: TryFrom<crate::xir::attr::Attr>);
    };

    (@evty $evty:ty) => {
        $evty
    };

    // If no ValueError type is provided,
    //   then it's not possible for values to fail parsing
    //     (their SymbolId is their final value).
    (@evty) => {
        std::convert::Infallible
    };

    // Optional attribute if input above is of the form `(QN_FOO?) => ...`.
    (@if_missing_req ? $from:ident.$field:ident $body:block) => {
        // This is an optional field;
        //   do nothing.
    };

    // Otherwise required.
    (@if_missing_req $from:ident.$field:ident $body:block) => {
        if $from.$field.is_none() {
            $body
        }
    };

    // Optional attribute if input above is of the form `(QN_FOO?) => ...`.
    (@into_value ? $from:ident) => {
        $from.try_into().map(Some)
    };

    (@into_value $from:ident) => {
        $from.try_into()
    };

    // Optional attribute if input above is of the form `(QN_FOO?) => ...`.
    (@maybe_value ? $from:ident.$field:ident) => {
        // This does not produce a great error if the user forgets to use an
        //   `Option` type for optional attributes,
        //     but the comment is better than nothing.
        match $from.$field { // field type must be Option<T>
            Some((value, _kspan)) => value,
            None => None,
        }
    };

    // Otherwise,
    //   if the above `@maybe_value` does not match,
    //   the attribute is required.
    (@maybe_value $from:ident.$field:ident) => {
        // This assumes that we've already validated via
        //   `@validate_req` above,
        //     and so should never actually panic.
        match $from.$field.unwrap() {
            (value, _kspan) => value
        }
    };
}

#[cfg(test)]
mod test;
