// ASG lowering into xmle sections
//
//  Copyright (C) 2014-2023 Ryan Specialty, LLC.
//
//  This file is part of TAME.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

//! Lowering of the [ASG](crate::asg) into `xmle` [`XmleSections`].
//!
//! See the [parent module](super) for more information.

use std::iter::once;

use super::section::{SectionsError, XmleSections};
use crate::{
    asg::{Asg, Ident, IdentKind, Object, ObjectIndex},
    diagnose::{Annotate, Diagnostic},
    diagnostic_unreachable,
    fmt::{
        AndConjList, DisplayWrapper, JoinListWrap, ListDisplayWrapper, Raw,
        TtQuote,
    },
    parse::util::SPair,
    span::UNKNOWN_SPAN,
    sym::{st, GlobalSymbolResolve, SymbolId},
};
use petgraph::visit::DfsPostOrder;

// Result of [`sort`].
pub type SortResult<T> = Result<T, SortError>;

/// Lower ASG into [`XmleSections`] by ordering relocatable text fragments.
///
/// This performs the equivalent of a topological sort,
///   although function cycles are permitted.
/// The actual operation performed is a post-order depth-first traversal.
pub fn sort<'a, S: XmleSections<'a>>(asg: &'a Asg, mut dest: S) -> SortResult<S>
where
    S: XmleSections<'a>,
{
    // TODO: we should check for cycles as we sort (as the POC did).
    check_cycles(asg)?;

    // TODO: Encapsulate petgraph.
    // This is technically a topological sort, but functions have cycles.
    let mut dfs = DfsPostOrder::new(&asg.graph, asg.root(UNKNOWN_SPAN).into());

    // These are always generated by the map compiler,
    //   but do not have edges that would allow them to be properly ordered
    //   (adding an edge to every map object would be wasteful).
    dest.push(get_ident(asg, st::L_MAP_UUUHEAD))?;
    dest.push(get_ident(asg, st::L_RETMAP_UUUHEAD))?;

    while let Some(index) = dfs.next(&asg.graph) {
        // TODO: `new` really ought to be private to the `asg` module,
        //   so let's work on fully encapsulating Petgraph.
        let oi = ObjectIndex::<Object>::new(index, UNKNOWN_SPAN);

        match asg.get(oi).expect("missing object") {
            Object::Root(_) => (),
            Object::Ident(ident) => dest.push(ident)?,

            obj => {
                diagnostic_unreachable!(
                    obj.internal_error(
                        "this object should not be present on the graph"
                    )
                    .into(),
                    "linker graph should not contain {obj}",
                )
            }
        }
    }

    dest.push(get_ident(asg, st::L_MAP_UUUTAIL))?;
    dest.push(get_ident(asg, st::L_RETMAP_UUUTAIL))?;

    Ok(dest)
}

fn get_ident<S>(depgraph: &Asg, name: S) -> &Ident
where
    S: Into<SymbolId>,
{
    let oi_root = depgraph.root(UNKNOWN_SPAN);
    let sym = name.into();

    depgraph
        .lookup(oi_root, SPair(sym, UNKNOWN_SPAN))
        .and_then(|id| depgraph.get(id))
        .unwrap_or_else(|| {
            panic!("missing internal identifier: {}", sym.lookup_str())
        })
}

/// Check graph for cycles
///
/// We want to catch any cycles before we start using the graph.
///   Unfortunately, we need to allow cycles for our [`IdentKind::Func`]
///   so we cannot use the typical algorithms in a straightforward manner.
///
/// We loop through all SCCs and check that they are not all functions. If
///   they are, we ignore the cycle, otherwise we will return an error.
fn check_cycles(asg: &Asg) -> SortResult<()> {
    // While `tarjan_scc` does do a topological sort, it does not suit our
    // needs because we need to filter out some allowed cycles. It would
    // still be possible to use this, but we also need to only check nodes
    // that are attached to our "roots". We are doing our own sort and as of
    // the initial writing, this does not have a significant performance
    // impact.
    let sccs = petgraph::algo::tarjan_scc(&asg.graph);

    let cycles: Vec<Vec<SPair>> = sccs
        .into_iter()
        .filter_map(|scc| {
            // For single-node SCCs, we just need to make sure they are
            // not neighbors with themselves.
            if scc.len() == 1
                && !asg.graph.neighbors(scc[0]).any(|nx| nx == scc[0])
            {
                return None;
            }

            let is_all_funcs = scc.iter().all(|ni| {
                let oi = ObjectIndex::<Object>::new(*ni, UNKNOWN_SPAN);
                let ident = asg.get(oi).expect("missing node");
                matches!(
                    ident.as_ident_ref().and_then(Ident::kind),
                    Some(IdentKind::Func(..))
                )
            });

            if is_all_funcs {
                None
            } else {
                // TODO: ...these aren't references, they're the actual
                //   identifiers,
                //     so the diagnostic message isn't that great of a guide
                //     yet!
                //   Use reference spans once they're available.
                let cycles = scc
                    .iter()
                    .map(|ni| ObjectIndex::<Object>::new(*ni, UNKNOWN_SPAN))
                    .filter_map(|oi| {
                        asg.get(oi).unwrap().as_ident_ref().map(Ident::name)
                    })
                    .collect();
                Some(cycles)
            }
        })
        .collect();

    if cycles.is_empty() {
        Ok(())
    } else {
        Err(SortError::Cycles(cycles))
    }
}

/// Error during graph sorting.
///
/// These errors reflect barriers to meaningfully understanding the
///   properties of the data in the graph with respect to sorting.
/// It does not represent bad underlying data that does not affect the
///   sorting process.
#[derive(Debug, PartialEq)]
pub enum SortError {
    /// Error while lowering into [`XmleSections`].
    SectionsError(SectionsError),

    /// The graph has a cyclic dependency.
    Cycles(Vec<Vec<SPair>>),
}

impl From<SectionsError> for SortError {
    fn from(err: SectionsError) -> Self {
        Self::SectionsError(err)
    }
}

impl std::fmt::Display for SortError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Self::SectionsError(err) => err.fmt(f),
            Self::Cycles(cycles) => {
                let cycles_fmt = cycles
                    .iter()
                    .map(|cycle| {
                        let cycle_fmt = cycle
                            .iter()
                            .rev()
                            .chain(once(cycle.last().unwrap()))
                            .collect::<Vec<_>>();

                        // TODO: Wrappers ought to support nested lists.
                        JoinListWrap::<" -> ", Raw>::wrap(&cycle_fmt)
                            .to_string()
                    })
                    .collect::<Vec<_>>();

                write!(
                    f,
                    "circular dependencies: {}",
                    AndConjList::<TtQuote>::wrap(&cycles_fmt),
                )
            }
        }
    }
}

impl std::error::Error for SortError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        None
    }
}

impl Diagnostic for SortError {
    fn describe(&self) -> Vec<crate::diagnose::AnnotatedSpan> {
        use SortError::*;

        match self {
            SectionsError(e) => e.describe(),

            // TODO: In future it'd be far less confusing to have a single
            //   error per cycle.
            Cycles(cycles) => cycles
                .iter()
                .flat_map(|cycle| {
                    let n = cycle.len();
                    let ident = cycle.last().unwrap();

                    cycle.iter().rev().enumerate().map(|(i, spair)| {
                        spair.note(match i {
                            0 => format!(
                                "[0/{n}] the cycle begins here, depending on..."
                            ),
                            _ => format!(
                                "[{i}/{n}] ...this identifier, which depends on..."
                            )
                        })
                    })
                        .chain(once(ident.error(format!(
                            "[{n}/{n}] ...the first identifier once again, \
                                creating the cycle"
                        ))))
                        .chain(vec![
                            ident.help(format!(
                                "the value of {} cannot be computed because its",
                                TtQuote::wrap(ident),
                            )),
                            ident.help(
                                "  definition requires first computing itself.",
                            ),
                            ident.help(
                                "in the future the above output will emphasize the "
                            ),
                            ident.help(
                                "  references to the identifiers rather than their "
                            ),
                            ident.help(
                                "  definition sites."
                            )
                        ])
                        .collect::<Vec<_>>()
                })
                .collect(),
        }
    }
}

#[cfg(test)]
mod test;
