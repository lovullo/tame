// TAME frontend parser
//
//  Copyright (C) 2014-2021 Ryan Specialty Group, LLC.
//
//  This file is part of TAME.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

//! Recovering, zero-copy, scannerless parsers for TAME frontends.
//!
//! See the [parent module](super) for more information.

use std::{borrow::Cow, fmt::Display, num::NonZeroUsize};

/// Recovering, zero-copy, scannerless parser.
pub trait FrontendParser<'l, T, E> {
    /// Human-readable short description of parser.
    ///
    /// TAME consists of a number of source languages, so this should be
    ///   sufficient to state what parser was chosen for a given source
    ///   file.
    fn desc() -> &'static str;

    /// Attempt to parse the next token.
    ///
    /// A [`FrontendEvent::Token`] contains common information about the
    ///   encountered lexeme and source byte interval,
    ///     but the token kind is frontend-specific.
    ///
    /// When a parsing error occurs,
    ///   frontends are encouraged to self-correct if possible.
    /// If this is able to happen,
    ///   [`FrontendEvent::RecoverableError`] will be emitted with zero or
    ///     more tokens that may be used in place of the erroneous input to
    ///     possibly continue parsing in a useful way;
    ///       this can be used for further static analysis or error
    ///       checking.
    ///
    /// If the end of the file
    ///   (or end of the parsable region of a file)
    ///   has been reached,
    ///     [`FrontendEvent::Eof`] will be emitted,
    ///     unless a [`FrontendEvent::RecoverableError`] has been previous
    ///       emitted,
    ///         in which case [`FrontendError::EofWithRecoverableErrors`]
    ///           indicates that the caller should take special care in
    ///           determining whether parsing should be considered be to a
    ///           failure.
    fn parse_next(&mut self) -> FrontendResult<FrontendEvent<'l, T, E>, E>;
}

/// Raw input string associated with a token.
#[derive(Debug, PartialEq, Eq)]
pub struct Lexeme<'a>(Cow<'a, [u8]>);

/// A lexeme combined with a type (kind) and location.
///
/// The `interval` represents the starting and ending offset, inclusive, of
///   the lexeme used to produce this token.
/// The `kind` is the token type,
///   specific to each individual frontend.
///
/// Tokens are intended to be short-lived and lowered into another
///   intermediate representationÂ (IR) for further processing and analysis.
#[derive(Debug, PartialEq, Eq)]
pub struct Token<'l, T> {
    /// Token type and associated data.
    ///
    /// The token kind represents the parsed information and should always
    ///   be used in place of the lexeme (which may not be available),
    ///     unless referring back to the source input.
    kind: T,

    /// Raw input from which the token was generated.
    ///
    /// A lexeme may not be available if a token was generated by the
    ///   compiler in a manner that is not associated with any source
    ///   input.
    ///
    /// Since frontend parsers are zero-copy by default,
    ///   a lexeme may be available only immediately after a token is
    ///     emitted,
    ///       unless the caller wishes to copy its value.
    lexeme: Option<Lexeme<'l>>,

    /// Starting and ending offset of the lexeme, inclusive.
    ///
    /// An interval may not be available if a token was generated by the
    ///   compiler in a manner that is not associated with any source
    ///   input.
    interval: Option<(usize, NonZeroUsize)>,
}

/// Result of attempting to parse input for the next token.
#[derive(Debug, PartialEq)]
pub enum FrontendEvent<'l, T, E> {
    /// Successfully parsed token.
    Token(Token<'l, T>),

    /// An error occurred,
    ///   but one or more tokens are provided in an attempt to self-correct
    ///   so parsing may continue.
    ///
    /// The provided interval represents all source bytes consumed for all
    ///   recovery tokens;
    ///     parsing will continue at the next byte after the end of that
    ///     interval.
    /// The recovery token may very well be nonsense;
    ///   the goal is to continue parsing to find more errors,
    ///     not to infer a correct program.
    RecoverableError {
        /// Source error.
        source: E,

        /// Starting and ending offset of all bytes associated with this
        ///   error, inclusive.
        ///
        /// Note that recovery tokens may not have interval information if
        ///   their source input is not sensible.
        interval: (usize, usize),

        /// Zero or more tokens that may be substituted in place of the
        ///   erroneous input in an attempt to continue parsing.
        ///
        /// These recovery tokens are not guaranteed to be successful,
        ///   nor can they be used to confidently repair a program with
        ///   parse errors.
        recovery_tokens: Vec<Token<'l, T>>,
    },

    /// End of the file has been reached with no recoverable errors.
    ///
    /// See also [`FrontendError::EofWithRecoverableErrors`].
    Eof,
}

/// Error attempting to parse input for the next token.
#[derive(Debug, PartialEq, Eq)]
pub enum FrontendError<E> {
    /// An error occurred during parsing and the parser was either unable to
    ///   determine how to recover or did not attempt recovery.
    UnrecoverableError {
        /// Source error.
        source: E,

        /// Starting and ending byte offsets of source input that produced
        ///   the error.
        interval: (usize, usize),
    },

    /// EOF reached with recoverable errors.
    ///
    /// This error indicates that the end of the file has been reached,
    ///   but recoverable errors have been previously omitted,
    ///   and so parsing should fail.
    /// If the caller chooses to ignore this error and accept the recovery
    ///   tokens,
    ///     the emitted tokens may not represent a valid program.
    /// However,
    ///   if parsing was performed for syntax checking or static analysis,
    ///     then this error might be able to be safely ignored.
    ///
    /// See also [`FrontendEvent::Eof`].
    EofWithRecoverableErrors,
}

impl<E> Display for FrontendError<E> {
    fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(fmt, "TODO fmt")
    }
}

impl<E: std::fmt::Debug> std::error::Error for FrontendError<E> {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        None
    }
}

pub type FrontendResult<T, E> = Result<T, FrontendError<E>>;
